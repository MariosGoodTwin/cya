#!/usr/bin/env python
#
#	$0 <source_url_url> <base_dest_dir>
#
#	Example: $0 root@moya.dev.lsstcorp.org:/etc mjuric@archive.lsstcorp.org:/data/backups/moya
#

# /opt/cya/cya "ssh -CYA bkp@trac.lsstcorp.org duplicity-ex / scp://moya.dev.lsstcorp.org/%(dest)s" ~archive/backups/trac.lsstcorp.org 
# /opt/cya/cya "ssh -CYA bkp@trac.lsstcorp.org %(dest)s" ~archive/backups/trac.lsstcorp.org 
# cya ~archive/backups/tests "ssh -CYA bkp@trac.lsstcorp.org duplicity /home/mjuric scp://moya.dev.lsstcorp.org/%(dest)s --no-encryption --asynchronous-upload --volsize 100"

import time, os, os.path, glob, datetime, subprocess, itertools, argparse, socket, getpass, pipes, shlex

class Backup(object):
	backup_set_base = None		# Backup directory tree base (path)
	backup_cmd = None		# Backup command pattern

	def hardlink(self, files, dest_dir):
		new_files = [ os.path.join(dest_dir, os.path.basename(fn)) for fn in files ]
		#print '===', dest_dir
		for src, new in itertools.izip(files, new_files):
			#print 'hardlink: ', new, '->', src
			os.link(src, new)
		return new_files

	def no_backups_exist(self, dir):
		# Check if any backups exist in the directory
		# NOTE: duplicity specific
		for fn in glob.iglob(os.path.join(dir, '*.manifest')):
			return False
		return True

	def run_backup(self, dest_dir, full=False):
		cmd = shlex.split(self.backup_cmd % { 'dest': dest_dir, 'full': full });
		print "Executing: %s" % (" ".join((pipes.quote(s) for s in cmd)))
		exit()
		print "Performing backup:"
		p = subprocess.Popen(cmd, stdout=subprocess.PIPE)
		for line in p.stdout:
			print "--- %s" % (line),
		p.communicate()
		if p.returncode:
			raise subprocess.CalledProcessError(p.returncode, " ".join((pipes.quote(s) for s in cmd)))

		# return the full path to all files existing in the backup set directory
		files = [ fn for fn in (os.path.join(dest_dir, f) for f in os.listdir(dest_dir)) if os.path.isfile(fn) ]
		return files

	def do_backup(self, dest_dir):
		#print 'do_backup:', self.src_url, dest_dir

		if not os.path.exists(dest_dir):
			os.makedirs(dest_dir)

		if self.no_backups_exist(dest_dir):
			up_dir = os.path.dirname(dest_dir)
			if up_dir == self.backup_set_base:
				return self.run_backup(dest_dir, full=True)

			files = self.do_backup(up_dir)
			files = self.hardlink(files, dest_dir)
			print "Hardlinked from %s" % (dest_dir)
		else:
			files = self.run_backup(dest_dir, full=False)

		return files

	def date2dir(self, t):
		# Round down to the start of the week (weeks begin on Sunday)
		d = t.date()
		d -= datetime.timedelta((d.weekday() + 1) % 7)

		# Extract info, construct path
		dir = os.path.join(
			"%04d" % (d.year - d.year % 100),	# century
			"%04d" % (d.year - d.year % 10), 	# decade
			"%04d" % (d.year),			# year
			d.strftime("%Y-%m"),			# year-month
			d.isoformat()				# year-month-week
			)

		return dir

	def run(self):
		print "Time: %s" % self._now
		print "Adding to backup set: %s" % (self._dest_dir)
		self.do_backup(self._dest_dir)
		print "Finished backup to %s" % (self._dest_dir)

	def __init__(self, **kwargs):
		self.backup_set_base = kwargs['backup_set_base']
		self.backup_cmd = kwargs['backup_cmd']

		self._dest_dir = os.path.join(self.backup_set_base, self.date2dir(kwargs['now']))

		self._now = kwargs['now']


if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Multi-timescale backup driver')
	parser.add_argument('backup_set_base', type=str, help='Backup set directory (where to back up)')
	parser.add_argument('backup_cmd', type=str, help='Backup command pattern')

	parser.add_argument('--force-time', dest='now', default=str(datetime.datetime.today()), metavar='T', help='Force the current time to be T. Must be formatted as "YYYY-MM-DD [HH-MM-SS[.SS]]"')

	args = parser.parse_args()

	# Parse the time string
	try:
		args.now = datetime.datetime.strptime(args.now, '%Y-%m-%d %H:%M:%S.%f')
	except ValueError:
		try:
			args.now = datetime.datetime.strptime(args.now, '%Y-%m-%d %H:%M:%S')
		except ValueError:
			args.now = datetime.datetime.strptime(args.now, '%Y-%m-%d')

	bkp = Backup(**vars(args))
	bkp.run()
